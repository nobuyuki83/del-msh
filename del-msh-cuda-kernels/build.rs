use std::{
    env, fs,
    path::{Path, PathBuf},
    process::Command,
};
use walkdir::WalkDir;

fn nvcc() -> String {
    if let Ok(value) = env::var("CUDA_PATH") {
        dbg!("path_cuda", &value);
        value + "\\bin\\nvcc.exe"
    } else {
        // 必要なら環境変数 CUDA_PATH を見るなどして解決
        "nvcc".to_string()
    }
}

fn gen_fatbin(src: &Path, out_dir: &Path, include_dir: &[&Path]) {
    let name = src.file_stem().unwrap().to_string_lossy();
    let out = out_dir.join(format!("{name}.fatbin"));

    dbg!(src.is_file());
    dbg!(src.exists());

    // よく使うSM + 将来用PTXを入れた一例（調整してOK）
    let mut args: Vec<String> = vec!(
        "-fatbin".to_string(),
        src.to_str().unwrap().to_string(),
        "-o".to_string(),
        out.to_str().unwrap().to_string(),
        "-gencode=arch=compute_70,code=sm_70".to_string(),
        "-gencode=arch=compute_75,code=sm_75".to_string(),
        "-gencode=arch=compute_80,code=sm_80".to_string(),
        "-gencode=arch=compute_86,code=sm_86".to_string(),
        "-gencode=arch=compute_89,code=sm_89".to_string(),
        "-gencode=arch=compute_89,code=compute_89".to_string(), // PTXフォールバック
                                                    // 追加で -use_fast_math や -lineinfo なども可
    );

    if !include_dir.is_empty() {
        args.push("-I".to_string());
        for dir in include_dir {
            args.push(dir.to_str().unwrap().to_string());
        }
    }

    if let Ok(value) = env::var("NVCC_CCBIN") {
        args.push("-ccbin".to_string());
        args.push(value);
    }

    dbg!(&args);

    dbg!(nvcc());

    //let st = Command::new("nvcc").arg("--version").status().unwrap();
    //dbg!(st);

    let st = Command::new(nvcc())
        .args(&args)
        .status()
        .expect("failed to run nvcc");
    assert!(st.success(), "nvcc failed for {}", src.display());
    dbg!("hoge");
}

fn main() {
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

    fs::create_dir_all(&out_dir).unwrap();


    //let path_out_dir = std::path::Path::new(&path_out_dir).join("cpp_headers").join("del_geo");
    let geo_out_dir = std::path::Path::new(&out_dir).join("del_geo");
    // dbg!(&path_out_dir);
    std::fs::create_dir_all(&geo_out_dir).unwrap();
    del_geo_cpp_headers::HEADERS.write_files(&geo_out_dir);

    // cuda/ 以下の .cu をすべて fatbin 化
    let mut items = vec![];
    for e in WalkDir::new("cuda") {
        let e = e.unwrap();
        if e.file_type().is_file() && e.path().extension().and_then(|s| s.to_str()) == Some("cu") {
            println!("cargo:rerun-if-changed={}", e.path().display());
            //gen_fatbin(e.path(), &out_dir, &vec!());
            gen_fatbin(e.path(), &out_dir, &vec!(out_dir.as_path()));
            let stem = e.path().file_stem().unwrap().to_string_lossy().to_string();
            items.push(stem);
        }
    }

    // 埋め込み用の Rust モジュールを生成（name -> &'static [u8]）
    let mut rs = String::new();
    rs.push_str("// AUTO-GENERATED by build.rs\n");
    rs.push_str("use std::collections::HashMap;\n");
    rs.push_str("pub fn all() -> HashMap<&'static str, &'static [u8]> {\n");
    rs.push_str("  let mut m = HashMap::new();\n");
    for stem in &items {
        rs.push_str(&format!(
            "  m.insert(\"{name}\", include_bytes!(concat!(env!(\"OUT_DIR\"), \"/{name}.fatbin\")) as &'static [u8]);\n",
            name = stem
        ));
    }
    rs.push_str("  m\n}\n");

    fs::write(out_dir.join("fatbins.rs"), rs).unwrap();
}
